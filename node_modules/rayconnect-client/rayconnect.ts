import SimpleConnect from './simple'
import { EventEmitter } from 'events';


interface Permission {
  mode: string
  uid: string,
  scope: string,
  method: string,
  address: string,
}
interface Options {
  scopes: string,
  appID: string,
  space: string,
  type: string,
  url?: string,
  unsecure?: boolean
}
interface ServerData {
  sender: string,
  token: string,
  data: any,
  date: any,
  send?: Function,
}

interface QueryType {
  scope: string,
  address: string,
  method: string
}

interface Cloudstorage {
  Keys: Map<string, string>,
  setItem: Function,
  getItem: Function
}
interface ExecuteType {

  scope: string,
  uniqueID: string,
  TokenID: string,
  address: string,
  info: {
    method: string,
    data: any

  }
}
interface QueryCallback { (ServerData: ServerData, Query: QueryType): void }



class Rayconnect {

  public authed: boolean = false;
  public user: any
  public AuthEvent = new EventEmitter();
  public InterTime = 10;
  public Timeout = 3000;
  public loginData = { username: '', password: '' }
  public encode = true
  public socket: SimpleConnect;
  private InitCloud = false

  middlewares: Function[] = [];
  CloudStorage: Cloudstorage
  constructor(
    private ops: Options = {
      scopes: '',
      appID: 'rayconnect',
      space: '',
      type: 'client',
    },
    private token: any,
    private config: any
  ) {

    if (!this.ops.url) {
      this.ops.url = 'server-test.rayconnect.ir/socket.io/'
    }

    console.log(this.ops)
    const self = this;
    this.CloudStorage = {

      Keys: new Map(),
      setItem: function (key: string, value: string) {
        return self.SetCloudStorage({
          key,
          value
        })
      },
      getItem: function (key: string) {
        return new Promise((resolve, reject) => {


          if (self.InitCloud) {
            resolve(self.CloudStorage.Keys.get(key))
          }

          setTimeout(() => {
            reject("request timeout")
          }, 2000);
          let interTime = 20;
          const interval = setInterval(() => {

            if (self.InitCloud) {
              resolve(self.CloudStorage.Keys.get(key))
              clearInterval(interval)
            }




            interTime *= 2
          }, interTime);
        })


      }
    };

    this.socket = this.Connect()

    this.OnConnect(() => {




    })

    this.socket.on("app_data", (data: { encode: boolean; }) => {

      if (data.encode == false) {
        this.encode = data.encode
      }
    })
    this.socket.on('authed', (msg: any) => {

      const data = this.Dpack(msg)

      this.authed = true

      this.user = data.data


      this.AuthEvent.emit('authed', true)
    })


    this.socket.on('ack_gram', (msg: any) => {
      const data = this.Dpack(msg)

      // console.info(data)
    })

    this.DisOnConnect(() => {
      this.authed = false
      // this.AuthEvent.
    })
  }

  setProfile(data: any, TimeOutNumber = 6000) {
    return new Promise((resolve, rejects) => {
      this.socket.emit('profile', {
        method: 'SET',
        data: data
      })
      const TimeOut = setTimeout(() => {
        rejects(`request timeout : ${TimeOutNumber}`)


      }, TimeOutNumber);

      this.socket.readData('profile_set', (back: any) => {
        resolve(back)
        clearTimeout(TimeOut)
      })
    })

  }

  CloneCloudStorage(token: string, TimeOutNumber = 3000) {
    return new Promise((resolve, rejects) => {
      this.socket.emit('cloud_storage', {
        method: 'CLONE',
        data: token
      })
      const TimeOut = setTimeout(() => {
        rejects(`request timeout : ${TimeOutNumber}`)


      }, TimeOutNumber);

      this.socket.readData('cloud_storage_cloned', (back: any) => {
        resolve(back)
        clearTimeout(TimeOut)
      })
    })
  }
  SetCloudStorage(data: any, TimeOutNumber = 3000) {

    return new Promise((resolve, rejects) => {


      if (['setItem', 'getItem', 'removeItem', 'clear'].includes(data.key)) {

        return rejects('can not use reserved function as data')

      }
      this.socket.emit('cloud_storage', {
        method: 'SET',
        data: data
      })
      const TimeOut = setTimeout(() => {
        rejects(`request timeout : ${TimeOutNumber}`)


      }, TimeOutNumber);

      this.socket.readData('cloud_storage_set_' + data.key, (back: any) => {
        this.CloudStorage.Keys.set(data.key, data.value)
        resolve(back)
        clearTimeout(TimeOut)
      })
    })

  }
  LoadCloudStorage(TimeOutNumber = 3000) {

    return new Promise((resolve, rejects) => {

      this.socket.emit('cloud_storage', {
        method: 'LOAD'
      })
      const TimeOut = setTimeout(() => {
        rejects(`request timeout : ${TimeOutNumber}`)


      }, TimeOutNumber);

      this.socket.readData('cloud_storage_load', (data: any) => {

        resolve(this.CloudStorage)
        this.InitCloud = true

        clearTimeout(TimeOut)
        data.forEach((element: any) => {
          if (!['setItem', 'getItem', 'removeItem', 'clear'].includes(element.key)) {
            this.CloudStorage.Keys.set(element.key, element.value)
          }
        });
      })
    })

  }
  AuthEmitter(authed: any) {

    if (authed) {
      this.AuthEvent.emit('authed', true)
    }
  }
  AuthChecker(callback: { (arg0: boolean): void; (arg0: boolean): void; }) {
    const interval = setInterval(() => {

      if (this.authed) {
        callback(this.authed)
        clearInterval(interval)
      }
    }, 50)

    setTimeout(() => {

      callback(this.authed)
      clearInterval(interval)

    }, 3000);
  }
  Ack(data: any) {
    this.socket.emit('ack_gram', {
      reqID: data
    })
  }
  ObjectIdvalue = function (id: { id: { toString: () => void; }; }) {
    return id.id.toString();
  };
  OnConnect(callback: { (): void; (): void; }) {
    this.socket.on('connect', () => {
      callback()
    })
  }

  RequestOTP(phone: any, TimeOutNumber = 120000) {

    this.socket.emit('login', { phone })

    return new Promise((resolve, reject) => {



      const TimeOut = setTimeout(() => {
        reject(`request timeout : ${TimeOutNumber}`)


      }, TimeOutNumber);



      this.socket.readData('login', (msg: any) => {
        const data = this.Dpack(msg)

        clearTimeout(TimeOut)
        resolve(data)
      })
    })

  }

  VerifyPhone(phone: any, token: any, TimeOutNumber = 120000) {
    this.socket.emit('login', { phone, token })

    return new Promise((resolve, reject) => {



      const TimeOut = setTimeout(() => {
        reject(`request timeout : ${TimeOutNumber}`)


      }, TimeOutNumber);



      this.socket.readData('login', (msg: any) => {
        const data = this.Dpack(msg)

        clearTimeout(TimeOut)
        resolve(data)
      })
    })
  }

  async GetGuestAccess() {
    const guest = await this.Guest()


    return this.Auth(guest['data']['token'])
  }
  Guest(TimeOutNumber = 3000): any {
    return this.LoginWithPassword()
  }
  LoginWithPassword(data = { username: 'guest', password: 'guest' }, TimeOutNumber = 3000) {

    this.loginData = data
    this.socket.emit('loginup', data)

    return new Promise((resolve, reject) => {



      const TimeOut = setTimeout(() => {
        reject(`request timeout : ${TimeOutNumber}`)


      }, TimeOutNumber);



      this.socket.readData('login', (msg: any) => {
        const data = this.Dpack(msg)

        clearTimeout(TimeOut)
        resolve(data)
      })
    })
  }

  public LoginEvent(callback: (arg0: any) => void) {
    this.socket.on('login', (msg: any) => {
      const data = this.Dpack(msg)

      callback(data)
    })
  }


  DisOnConnect(callback: { (): void; (): void; }) {
    this.socket.on('disconnect', () => {
      callback()
    })
  }

  AuthOnConnect(token: any) {
    this.socket.on('connect', () => {
      this.Auth(token)
    })
  }

  Auth(token: any): any {
    this.socket.emit("auth", {
      token
    })


    return new Promise((resolve, reject) => {
      const timeout = setTimeout(() => {
        reject("request timeout.")
      }, 5000);
      this.AuthEvent.once('authed', () => {

        // load cloud storage when authed
        this.LoadCloudStorage()
          .then((data) => {
            resolve(this.user)
          })
        clearTimeout(timeout);
      })

    })






  }

  onAuth(input: string, input2: any) {
    // Auth(localStorage.token)
    let callback: { (arg0: boolean): void; (arg0: boolean): void; (arg0: boolean): void; (arg0: boolean): void; }
    let timer = this.Timeout
    let renable = false
    if (typeof input == 'function') {
      callback = input

    } else {
      if (input !== 'checker') {
        this.Auth(input)
      }

      if (input == 'checker') {
        timer = timer * 10000
        renable = true
      }

      callback = input2
    }

    if (renable) {
      callback(false)


    }
    const ins = setInterval(() => {
      if (this.authed) {
        callback(true)

        clearInterval(ins)
      }
    }, 10);

    const timeout = setTimeout(() => {
      if (!this.authed) {
        callback(false)

        clearInterval(ins)
      }
    }, timer);

    this.socket.on('no_authed', () => {
      clearTimeout(timeout)
      clearInterval(ins)
      callback(false)
    })


  }

  NoAuthed(callback: (arg0: boolean) => void) {
    this.socket.on('no_authed', () => {
      callback(false)
    })
  }


  Reconnect() {
    this.socket.reconnect()
  }


  Connect(): SimpleConnect {
    let wsProtocol = `${this.ops.unsecure ? 'ws://' : 'wss://'}`
    let connectionString = `${wsProtocol}${this.ops.url}?scopes=chat&appID=rayGap&space=chat&type=client&encode=true&EIO=3&transport=websocket`



    if (this.config) {
      connectionString = `${wsProtocol}${this.ops.url}?scopes=${this.ops.scopes}&appID=${this.ops.appID}&space=${this.ops.space}&type=${this.ops.type}&encode=${this.encode}&EIO=3&transport=websocket`

      if (this.token) {
        connectionString += `&token=${this.token}`
      }
    } else {
      connectionString += `?token=${this.token}`
    }
    this.authed = false
    this.user

    return this.socket = new SimpleConnect(connectionString)


  }



  execQuery(param: ExecuteType) {

    param.info.data = JSON.stringify(param.info.data)
    this.socket.emit("exec_gram", param)


  }

  News(callback: (arg0: any) => void) {
    this.socket.on('news', async (msg: any) => {


      this.Dpack(msg)
      const data = this.Dpack(msg)


      callback(data)
    })
  }



  Request(execObj: ExecuteType, queryObj: QueryType, TimeOutNumber = 3000) {




    return new Promise((resolve, reject) => {
      if (!this.authed) {
        return reject("not authed")
      }


      const TimeOut = setTimeout(() => {
        reject(`request timeout : ${TimeOutNumber}`)


      }, TimeOutNumber);
      this.execQuery(execObj)

      this.socket.readData('blocked', () => {

        reject(`blocked `)

        clearTimeout(TimeOut)

      })

      this.socket.readData(`exec_gram_${queryObj.address}`, async (msg: any) => {

        this.executeMiddleware(this.middlewares, {
          query: queryObj,
          exec: execObj,
          msg: msg
        }, (info: any, next: any) => {

          try {
            const data = this.Dpack(msg)
            if ((data.scope === queryObj.scope) && (data.address === queryObj.address) && (data
              .info
              .method === queryObj.method)) {



              // send ack
              this.Ack(data.info.reqID)





              // callback
              clearTimeout(TimeOut)

              const send = (sendData: any, token?: any) => {
                this.execQuery({
                  scope: queryObj.scope,
                  uniqueID: token ? '*' : data.sender,
                  TokenID: token ? data.token : '*',
                  address: queryObj.address + "/back",
                  info: {
                    method: queryObj.method,
                    data: sendData
                  }
                });
              }
              const resolvedata: ServerData = {
                sender: data.uid,
                token: data.token,
                data: JSON.parse(data.info.data),
                date: data.info.date,
                send: send
              }
              resolve(resolvedata)
            }
          } catch (error) {

            reject(error)
          }


        });


      });
    })



  }

  RequestBack(execObj: ExecuteType, TimeOutNumber = 3000) {



    // make query object from exec
    const queryObj: QueryType = {
      scope: execObj.scope,
      address: execObj.address + "/back",
      method: execObj.info.method
    }


    return new Promise((resolve, reject) => {
      if (!this.authed) {
        return reject("not authed")
      }


      const TimeOut = setTimeout(() => {
        reject(`request timeout : ${TimeOutNumber}`)


      }, TimeOutNumber);
      this.execQuery(execObj)

      this.socket.readData('blocked', () => {

        reject(`blocked `)

        clearTimeout(TimeOut)

      })

      this.socket.readData(`exec_gram_${queryObj.address}`, async (msg: any) => {

        this.executeMiddleware(this.middlewares, {
          query: queryObj,
          exec: execObj,
          msg: msg
        }, (info: any, next: any) => {

          try {
            const data = this.Dpack(msg)
            if ((data.scope === queryObj.scope) && (data.address === queryObj.address) && (data
              .info
              .method === queryObj.method)) {



              // send ack
              this.Ack(data.info.reqID)





              // callback
              clearTimeout(TimeOut)
              const send = (sendData: any, token?: any) => {
                this.execQuery({
                  scope: queryObj.scope,
                  uniqueID: token ? '*' : data.sender,
                  TokenID: token ? data.token : '*',
                  address: queryObj.address + "/back",
                  info: {
                    method: queryObj.method,
                    data: sendData
                  }
                });
              }
              const resolvedata: ServerData = {
                sender: data.uid,
                token: data.token,
                data: JSON.parse(data.info.data),
                date: data.info.date,
                send: send
              }
              resolve(resolvedata)
            }
          } catch (error) {

            reject(error)
          }


        });


      });
    })



  }

  Query(queryObj: QueryType, callback: QueryCallback) {


    if (!this.authed) {
      console.error('cannot exec without auth')
      return
    }



    this.socket.on(`exec_gram_${queryObj.address}`, async (msg: any) => {

      try {
        const data = this.Dpack(msg)
        if ((data.scope === queryObj.scope) && (data.address === queryObj.address) && (data
          .info
          .method === queryObj.method)) {





          // send ack
          this.Ack(data.info.reqID)

          const send = (sendData: any, token?: any) => {
            this.execQuery({
              scope: queryObj.scope,
              uniqueID: token ? '*' : data.sender,
              TokenID: token ? data.token : '*',
              address: queryObj.address + "/back",
              info: {
                method: queryObj.method,
                data: sendData
              }
            });
          }


          this.executeMiddleware(this.middlewares, {
            query: queryObj,
            msg: msg,
            send: send
          }, (info: any, next: any) => {
            callback({
              sender: data.uid,
              token: data.token,
              data: JSON.parse(data.info.data),
              date: data.info.date,
              send: send,
            }, queryObj)
          })


          // callback

        }
      } catch (error) {

        console.error(error)
      }

    });


  }
  addUser(param: any) {
    let self = this

    return new Promise(function (resolve, reject) {
      self.socket.emit("add_user", param)
      const c = setTimeout(() => {
        reject('not answer')
      }, 3000);

      self.socket.on("added_user", (msg: any) => {
        const data = self.Dpack(msg)

        clearTimeout(c)
        resolve(data)
      })

    });

  }

  changePermissions(param: Permission) {

    let self = this
    return new Promise((resolve, reject) => {
      self.socket.emit("change_permissions", param)
      let c = this.RejectChangePermissionRequest(reject);
      this.AcceptChangePermissionRequest(self, c, resolve);

    });



  }
  private AcceptChangePermissionRequest(self: this, c: NodeJS.Timeout, resolve: (value?: unknown) => void) {
    self.socket.readData("changed_permission", (msg: any) => {
      clearTimeout(c);
      resolve(msg);
    });
  }

  private RejectChangePermissionRequest(reject: (reason?: any) => void) {
    return setTimeout(() => {
      reject('not answer');
    }, 3000);
  }

  updatePassword(param: any) {


    let self = this


    return new Promise(function (resolve, reject) {
      self.socket.emit("update_password", param)
      const c = setTimeout(() => {
        reject('not answer')
      }, 3000);

      self.socket.on("updated_password", (msg: any) => {
        const data = self.Dpack(msg)


        clearTimeout(c)
        resolve(data)
      })

    });



  }

  use(fn: Function) {
    this.middlewares.push(fn);
  }

  executeMiddleware(middlewares: Function[], data: any, next: Function) {
    const composition = middlewares.reduceRight((next, fn) => (v: any) => {
      // collect next data

      const info = data;
      fn(info, next)
    }, next);
    composition(data);
  }
  Dpack(msg: any) {




    return msg;



  }


}

export default Rayconnect;
